KCPSM3  v1.30.      Ken Chapman (Xilinx-UK) 2005

The assembler for KCPSM3 Programmable State Machine

PASS 1 - Reading input PSM file

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80               ;8 simple LEDs. Is an OUTPUT port.
CONSTANT DATA_IN_PORT, 00         ;input data port. this is an INPUT port.
CONSTANT SSEG_PORT0, 40
CONSTANT SSEG_PORT1, 20
CONSTANT SSEG_PORT2, 10
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00        ;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01        ;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02        ;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03        ;Preserve s3 contents during ISR
;
CONSTANT LED_pattern, 04            ;remember state of LEDs (8-bit counter in this case)
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F       ;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D           ;carriage return
CONSTANT character_question, 3F     ;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21      ;'!'
CONSTANT character_BS, 08           ;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 01                         ;clear 1 second counter and set first LED
STORE s0, LED_pattern
OUTPUT s0, LED_port
LOAD sF, 00                          ;set "down" register to 0.
;
ENABLE INTERRUPT                    ;enable one second heart beat
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: CALL delay_1s;
check_switches: INPUT s0,DATA_IN_PORT               ;get status of switches
TEST s0, 01                     ;test to see if switch 0 is 1
JUMP NZ, just_clear_the_display      ;if switch 0 is 1, display
;if the switches are not 0, then shift the display left
TEST s0, 02                             ;if switch1 is 1, call add, otherwise, subtract.
JUMP NZ, call_sub
call_add:   CALL add_1_to_counter
JUMP display_the_counter
call_sub:   CALL sub_1_to_counter
display_the_counter: CALL update_seven_segments
CALL delay_100ms                     ; change to 200ms delay
CALL delay_100ms
JUMP check_switches;
just_clear_the_display:   load s8, 00;
load s9, 00;
load sA, 00;
CALL update_seven_segments
JUMP main_program;
add_1_to_counter:         add s8, 01
addcy s9, 00
addcy sA, 00
RETURN
sub_1_to_counter:       sub s8, 01
subcy s9, 00
subcy sA, 00
RETURN
update_seven_segments : output s8, SSEG_PORT0
output s9, SSEG_PORT1
output sA, SSEG_PORT2
RETURN
;**************************************************************************************
; Routines to display hexadecimal values
;**************************************************************************************
;
;
; Convert hexadecimal value provided in register s0 into ASCII characters
;
; The value provided must can be any value in the range 00 to FF and will be converted into
; two ASCII characters.
;     The upper nibble will be represented by an ASCII character returned in register s3.
;     The lower nibble will be represented by an ASCII character returned in register s2.
;
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
; hexadecimal requiring a further addition of 07 to the 30 already added.
;
; Registers used s0, s2 and s3.
;
hex_byte_to_ASCII: LOAD s2, s0                         ;remember value supplied
SR0 s0                              ;isolate upper nibble
SR0 s0
SR0 s0
SR0 s0
CALL hex_to_ASCII                   ;convert
LOAD s3, s0                         ;upper nibble value in s3
LOAD s0, s2                         ;restore complete value
AND s0, 0F                          ;isolate lower nibble
CALL hex_to_ASCII                   ;convert
LOAD s2, s0                         ;lower nibble value in s2
RETURN
;
; Convert hexadecimal value provided in register s0 into ASCII character
;
;Register used s0
;
hex_to_ASCII: SUB s0, 0A                          ;test if value is in range 0 to 9
JUMP C, number_char
ADD s0, 07                          ;ASCII char A to F in range 41 to 46
number_char: ADD s0, 3A                          ;ASCII char 0 to 9 in range 30 to 40
RETURN
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64                         ;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR: STORE s0, ISR_preserve_s0           ;preserve register
FETCH s0, LED_pattern               ;read current counter value
test_bot:   TEST s0, 01                         ;if bottom, reverse direction
JUMP NZ, go_up
test_top:   TEST s0, 80
JUMP NZ, go_down
JUMP shift
go_up:  LOAD sF, 00
JUMP shift
go_down:LOAD sF, 01
shift:  TEST sF, 01
JUMP Z, shift_up
shift_down: SR0 s0
JUMP display_leds
shift_up:   SL0 s0
display_leds:  STORE s0, LED_pattern               ;store new counter value
OUTPUT s0, LED_port                 ;display counter value on LEDs
FETCH s0, ISR_preserve_s0           ;restore register
RETURNI ENABLE
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 2 - Testing Instructions

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
CONSTANT SSEG_PORT0, 40
CONSTANT SSEG_PORT1, 20
CONSTANT SSEG_PORT2, 10
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
;
CONSTANT LED_pattern, 04;remember state of LEDs (8-bit counter in this case)
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D;carriage return
CONSTANT character_question, 3F;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21;'!'
CONSTANT character_BS, 08;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 01;clear 1 second counter and set first LED
STORE s0, LED_pattern
OUTPUT s0, LED_port
LOAD sF, 00;set "down" register to 0.
;
ENABLE INTERRUPT;enable one second heart beat
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: CALL delay_1s;
check_switches: INPUT s0, DATA_IN_PORT;get status of switches
TEST s0, 01;test to see if switch 0 is 1
JUMP NZ, just_clear_the_display;if switch 0 is 1, display
;if the switches are not 0, then shift the display left
TEST s0, 02;if switch1 is 1, call add, otherwise, subtract.
JUMP NZ, call_sub
call_add: CALL add_1_to_counter
JUMP display_the_counter
call_sub: CALL sub_1_to_counter
display_the_counter: CALL update_seven_segments
CALL delay_100ms; change to 200ms delay
CALL delay_100ms
JUMP check_switches;
just_clear_the_display: load s8, 00;
load s9, 00;
load sA, 00;
CALL update_seven_segments
JUMP main_program;
add_1_to_counter: add s8, 01
addcy s9, 00
addcy sA, 00
RETURN
sub_1_to_counter: sub s8, 01
subcy s9, 00
subcy sA, 00
RETURN
update_seven_segments: output s8, SSEG_PORT0
output s9, SSEG_PORT1
output sA, SSEG_PORT2
RETURN
;**************************************************************************************
; Routines to display hexadecimal values
;**************************************************************************************
;
;
; Convert hexadecimal value provided in register s0 into ASCII characters
;
; The value provided must can be any value in the range 00 to FF and will be converted into
; two ASCII characters.
;     The upper nibble will be represented by an ASCII character returned in register s3.
;     The lower nibble will be represented by an ASCII character returned in register s2.
;
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
; hexadecimal requiring a further addition of 07 to the 30 already added.
;
; Registers used s0, s2 and s3.
;
hex_byte_to_ASCII: LOAD s2, s0;remember value supplied
SR0 s0;isolate upper nibble
SR0 s0
SR0 s0
SR0 s0
CALL hex_to_ASCII;convert
LOAD s3, s0;upper nibble value in s3
LOAD s0, s2;restore complete value
AND s0, 0F;isolate lower nibble
CALL hex_to_ASCII;convert
LOAD s2, s0;lower nibble value in s2
RETURN
;
; Convert hexadecimal value provided in register s0 into ASCII character
;
;Register used s0
;
hex_to_ASCII: SUB s0, 0A;test if value is in range 0 to 9
JUMP C, number_char
ADD s0, 07;ASCII char A to F in range 41 to 46
number_char: ADD s0, 3A;ASCII char 0 to 9 in range 30 to 40
RETURN
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR: STORE s0, ISR_preserve_s0;preserve register
FETCH s0, LED_pattern;read current counter value
test_bot: TEST s0, 01;if bottom, reverse direction
JUMP NZ, go_up
test_top: TEST s0, 80
JUMP NZ, go_down
JUMP shift
go_up: LOAD sF, 00
JUMP shift
go_down: LOAD sF, 01
shift: TEST sF, 01
JUMP Z, shift_up
shift_down: SR0 s0
JUMP display_leds
shift_up: SL0 s0
display_leds: STORE s0, LED_pattern;store new counter value
OUTPUT s0, LED_port;display counter value on LEDs
FETCH s0, ISR_preserve_s0;restore register
RETURNI ENABLE
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 3 - Resolving addresses and line labels

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
000 CONSTANT SSEG_PORT0, 40
000 CONSTANT SSEG_PORT1, 20
000 CONSTANT SSEG_PORT2, 10
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 ;
000 CONSTANT LED_pattern, 04;remember state of LEDs (8-bit counter in this case)
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 01;clear 1 second counter and set first LED
001 STORE s0, LED_pattern
002 OUTPUT s0, LED_port
003 LOAD sF, 00;set "down" register to 0.
004 ;
004 ENABLE INTERRUPT;enable one second heart beat
005 
;**************************************************************************************
005 ; Main program
005 
;**************************************************************************************
005 ;
005 ; Display welcome message for design
005 ;
005 main_program: CALL delay_1s;
006 check_switches: INPUT s0, DATA_IN_PORT;get status of switches
007 TEST s0, 01;test to see if switch 0 is 1
008 JUMP NZ, just_clear_the_display;if switch 0 is 1, display
009 ;if the switches are not 0, then shift the display left
009 TEST s0, 02;if switch1 is 1, call add, otherwise, subtract.
00A JUMP NZ, call_sub
00B call_add: CALL add_1_to_counter
00C JUMP display_the_counter
00D call_sub: CALL sub_1_to_counter
00E display_the_counter: CALL update_seven_segments
00F CALL delay_100ms; change to 200ms delay
010 CALL delay_100ms
011 JUMP check_switches;
012 just_clear_the_display: LOAD s8, 00;
013 LOAD s9, 00;
014 LOAD sA, 00;
015 CALL update_seven_segments
016 JUMP main_program;
017 add_1_to_counter: ADD s8, 01
018 ADDCY s9, 00
019 ADDCY sA, 00
01A RETURN
01B sub_1_to_counter: SUB s8, 01
01C SUBCY s9, 00
01D SUBCY sA, 00
01E RETURN
01F update_seven_segments: OUTPUT s8, SSEG_PORT0
020 OUTPUT s9, SSEG_PORT1
021 OUTPUT sA, SSEG_PORT2
022 RETURN
023 
;**************************************************************************************
023 ; Routines to display hexadecimal values
023 
;**************************************************************************************
023 ;
023 ;
023 ; Convert hexadecimal value provided in register s0 into ASCII characters
023 ;
023 
; The value provided must can be any value in the range 00 to FF and will be converted into
023 ; two ASCII characters.
023 
;     The upper nibble will be represented by an ASCII character returned in register s3.
023 
;     The lower nibble will be represented by an ASCII character returned in register s2.
023 ;
023 
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
023 
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
023 ; hexadecimal requiring a further addition of 07 to the 30 already added.
023 ;
023 ; Registers used s0, s2 and s3.
023 ;
023 hex_byte_to_ASCII: LOAD s2, s0;remember value supplied
024 SR0 s0;isolate upper nibble
025 SR0 s0
026 SR0 s0
027 SR0 s0
028 CALL hex_to_ASCII;convert
029 LOAD s3, s0;upper nibble value in s3
02A LOAD s0, s2;restore complete value
02B AND s0, 0F;isolate lower nibble
02C CALL hex_to_ASCII;convert
02D LOAD s2, s0;lower nibble value in s2
02E RETURN
02F ;
02F ; Convert hexadecimal value provided in register s0 into ASCII character
02F ;
02F ;Register used s0
02F ;
02F hex_to_ASCII: SUB s0, 0A;test if value is in range 0 to 9
030 JUMP C, number_char
031 ADD s0, 07;ASCII char A to F in range 41 to 46
032 number_char: ADD s0, 3A;ASCII char 0 to 9 in range 30 to 40
033 RETURN
034 
;**************************************************************************************
034 ; Software delay routines
034 
;**************************************************************************************
034 ;
034 ; Delay of 1us.
034 ;
034 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
034 
; instruction executes in 2 clock cycles making the calculation highly predictable.
034 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
034 ; in the initiating code. Interrupts may effect software derived delays.
034 ;
034 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
034 ;
034 ; Registers used s0
034 ;
034 delay_1us: LOAD s0, delay_1us_constant
035 wait_1us: SUB s0, 01
036 JUMP NZ, wait_1us
037 RETURN
038 ;
038 ; Delay of 40us.
038 ;
038 ; Registers used s0, s1
038 ;
038 delay_40us: LOAD s1, 28;40 x 1us = 40us
039 wait_40us: CALL delay_1us
03A SUB s1, 01
03B JUMP NZ, wait_40us
03C RETURN
03D ;
03D ;
03D ; Delay of 1ms.
03D ;
03D ; Registers used s0, s1, s2
03D ;
03D delay_1ms: LOAD s2, 19;25 x 40us = 1ms
03E wait_1ms: CALL delay_40us
03F SUB s2, 01
040 JUMP NZ, wait_1ms
041 RETURN
042 ;
042 ; Delay of 20ms.
042 ;
042 ; Delay of 20ms used during initialisation.
042 ;
042 ; Registers used s0, s1, s2, s3
042 ;
042 delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
043 wait_20ms: CALL delay_1ms
044 SUB s3, 01
045 JUMP NZ, wait_20ms
046 RETURN
047 delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
048 wait_100ms: CALL delay_1ms
049 SUB s3, 01
04A JUMP NZ, wait_100ms
04B RETURN
04C ;
04C ; Delay of approximately 1 second.
04C ;
04C ; Registers used s0, s1, s2, s3, s4
04C ;
04C delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
04D wait_1s: CALL delay_20ms
04E SUB s4, 01
04F JUMP NZ, wait_1s
050 RETURN
051 ;
051 ;
051 ;
051 
;**************************************************************************************
051 ; Interrupt Service Routine (ISR)
051 
;**************************************************************************************
051 ;
051 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
051 ; on the 8 LEDs.
051 ;
051 ISR: STORE s0, ISR_preserve_s0;preserve register
052 FETCH s0, LED_pattern;read current counter value
053 test_bot: TEST s0, 01;if bottom, reverse direction
054 JUMP NZ, go_up
055 test_top: TEST s0, 80
056 JUMP NZ, go_down
057 JUMP shift
058 go_up: LOAD sF, 00
059 JUMP shift
05A go_down: LOAD sF, 01
05B shift: TEST sF, 01
05C JUMP Z, shift_up
05D shift_down: SR0 s0
05E JUMP display_leds
05F shift_up: SL0 s0
060 display_leds: STORE s0, LED_pattern;store new counter value
061 OUTPUT s0, LED_port;display counter value on LEDs
062 FETCH s0, ISR_preserve_s0;restore register
063 RETURNI ENABLE
064 ;
064 ;
064 
;**************************************************************************************
064 ; Interrupt Vector
064 
;**************************************************************************************
064 ;
064 ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 4 - Resolving Operands

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
000 CONSTANT SSEG_PORT0, 40
000 CONSTANT SSEG_PORT1, 20
000 CONSTANT SSEG_PORT2, 10
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 ;
000 CONSTANT LED_pattern, 04;remember state of LEDs (8-bit counter in this case)
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 01;clear 1 second counter and set first LED
001 STORE s0, LED_pattern
002 OUTPUT s0, LED_port
003 LOAD sF, 00;set "down" register to 0.
004 ;
004 ENABLE INTERRUPT;enable one second heart beat
005 
;**************************************************************************************
005 ; Main program
005 
;**************************************************************************************
005 ;
005 ; Display welcome message for design
005 ;
005 main_program: CALL delay_1s;
006 check_switches: INPUT s0, DATA_IN_PORT;get status of switches
007 TEST s0, 01;test to see if switch 0 is 1
008 JUMP NZ, just_clear_the_display;if switch 0 is 1, display
009 ;if the switches are not 0, then shift the display left
009 TEST s0, 02;if switch1 is 1, call add, otherwise, subtract.
00A JUMP NZ, call_sub
00B call_add: CALL add_1_to_counter
00C JUMP display_the_counter
00D call_sub: CALL sub_1_to_counter
00E display_the_counter: CALL update_seven_segments
00F CALL delay_100ms; change to 200ms delay
010 CALL delay_100ms
011 JUMP check_switches;
012 just_clear_the_display: LOAD s8, 00;
013 LOAD s9, 00;
014 LOAD sA, 00;
015 CALL update_seven_segments
016 JUMP main_program;
017 add_1_to_counter: ADD s8, 01
018 ADDCY s9, 00
019 ADDCY sA, 00
01A RETURN
01B sub_1_to_counter: SUB s8, 01
01C SUBCY s9, 00
01D SUBCY sA, 00
01E RETURN
01F update_seven_segments: OUTPUT s8, SSEG_PORT0
020 OUTPUT s9, SSEG_PORT1
021 OUTPUT sA, SSEG_PORT2
022 RETURN
023 
;**************************************************************************************
023 ; Routines to display hexadecimal values
023 
;**************************************************************************************
023 ;
023 ;
023 ; Convert hexadecimal value provided in register s0 into ASCII characters
023 ;
023 
; The value provided must can be any value in the range 00 to FF and will be converted into
023 ; two ASCII characters.
023 
;     The upper nibble will be represented by an ASCII character returned in register s3.
023 
;     The lower nibble will be represented by an ASCII character returned in register s2.
023 ;
023 
; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
023 
; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
023 ; hexadecimal requiring a further addition of 07 to the 30 already added.
023 ;
023 ; Registers used s0, s2 and s3.
023 ;
023 hex_byte_to_ASCII: LOAD s2, s0;remember value supplied
024 SR0 s0;isolate upper nibble
025 SR0 s0
026 SR0 s0
027 SR0 s0
028 CALL hex_to_ASCII;convert
029 LOAD s3, s0;upper nibble value in s3
02A LOAD s0, s2;restore complete value
02B AND s0, 0F;isolate lower nibble
02C CALL hex_to_ASCII;convert
02D LOAD s2, s0;lower nibble value in s2
02E RETURN
02F ;
02F ; Convert hexadecimal value provided in register s0 into ASCII character
02F ;
02F ;Register used s0
02F ;
02F hex_to_ASCII: SUB s0, 0A;test if value is in range 0 to 9
030 JUMP C, number_char
031 ADD s0, 07;ASCII char A to F in range 41 to 46
032 number_char: ADD s0, 3A;ASCII char 0 to 9 in range 30 to 40
033 RETURN
034 
;**************************************************************************************
034 ; Software delay routines
034 
;**************************************************************************************
034 ;
034 ; Delay of 1us.
034 ;
034 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
034 
; instruction executes in 2 clock cycles making the calculation highly predictable.
034 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
034 ; in the initiating code. Interrupts may effect software derived delays.
034 ;
034 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
034 ;
034 ; Registers used s0
034 ;
034 delay_1us: LOAD s0, delay_1us_constant
035 wait_1us: SUB s0, 01
036 JUMP NZ, wait_1us
037 RETURN
038 ;
038 ; Delay of 40us.
038 ;
038 ; Registers used s0, s1
038 ;
038 delay_40us: LOAD s1, 28;40 x 1us = 40us
039 wait_40us: CALL delay_1us
03A SUB s1, 01
03B JUMP NZ, wait_40us
03C RETURN
03D ;
03D ;
03D ; Delay of 1ms.
03D ;
03D ; Registers used s0, s1, s2
03D ;
03D delay_1ms: LOAD s2, 19;25 x 40us = 1ms
03E wait_1ms: CALL delay_40us
03F SUB s2, 01
040 JUMP NZ, wait_1ms
041 RETURN
042 ;
042 ; Delay of 20ms.
042 ;
042 ; Delay of 20ms used during initialisation.
042 ;
042 ; Registers used s0, s1, s2, s3
042 ;
042 delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
043 wait_20ms: CALL delay_1ms
044 SUB s3, 01
045 JUMP NZ, wait_20ms
046 RETURN
047 delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
048 wait_100ms: CALL delay_1ms
049 SUB s3, 01
04A JUMP NZ, wait_100ms
04B RETURN
04C ;
04C ; Delay of approximately 1 second.
04C ;
04C ; Registers used s0, s1, s2, s3, s4
04C ;
04C delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
04D wait_1s: CALL delay_20ms
04E SUB s4, 01
04F JUMP NZ, wait_1s
050 RETURN
051 ;
051 ;
051 ;
051 
;**************************************************************************************
051 ; Interrupt Service Routine (ISR)
051 
;**************************************************************************************
051 ;
051 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
051 ; on the 8 LEDs.
051 ;
051 ISR: STORE s0, ISR_preserve_s0;preserve register
052 FETCH s0, LED_pattern;read current counter value
053 test_bot: TEST s0, 01;if bottom, reverse direction
054 JUMP NZ, go_up
055 test_top: TEST s0, 80
056 JUMP NZ, go_down
057 JUMP shift
058 go_up: LOAD sF, 00
059 JUMP shift
05A go_down: LOAD sF, 01
05B shift: TEST sF, 01
05C JUMP Z, shift_up
05D shift_down: SR0 s0
05E JUMP display_leds
05F shift_up: SL0 s0
060 display_leds: STORE s0, LED_pattern;store new counter value
061 OUTPUT s0, LED_port;display counter value on LEDs
062 FETCH s0, ISR_preserve_s0;restore register
063 RETURNI ENABLE
064 ;
064 ;
064 
;**************************************************************************************
064 ; Interrupt Vector
064 
;**************************************************************************************
064 ;
3FF ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 5 - Writing reformatted PSM file
           pracpico.fmt

PASS 6 - Writing assembler log file
           pracpico.log

PASS 7 - Writing coefficient file
           pracpico.coe

PASS 8 - Writing VHDL memory definition file
           pracpico.vhd

PASS 9 - Writing Verilog memory definition file
           pracpico.v

PASS 10 - Writing System Generator memory definition file
           pracpico.m

PASS 11 - Writing memory definition files
           pracpico.hex
           pracpico.dec
           pracpico.mem


KCPSM3 successful.

KCPSM3 complete.

